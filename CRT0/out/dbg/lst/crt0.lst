     1                                  %use masm
     2                                  BITS 64
     3                                  ;Need to modify slightly to 
     4                                  extern main
     5                                  extern _BSS_START_
     6                                  extern _BSS_END_
     7                                  extern _argv    ;Argument Vector
     8                                  extern _argc    ;Argument Count
     9                                  extern _env     ;Environment
    10                                  
    11                                  global start 
    12                                  global __main
    13                                      section .text
    14                                  ;TODO:
    15                                  ;1) Paragraph align the stack (downwards ofc)
    16                                  ;2) Clean the BSS
    17                                  ;3) Get a pointer to the command line. Count the number of times 
    18                                  ;   a space/tab region appears, to pass as argc in rcx and the 
    19                                  ;   pointer to start of the command line in rdx.
    20                                  ;   Make sure to null terminate each string 
    21                                  ;       (replace first char in space region with 00).
    22                                  ;
    23                                  ;4) Call main.
    24                                  ;5) If eax > 0FFh, set al = 0FFh and 41h/AH=4Ch exit
    25                                  ;Future expansion:
    26                                  ;Hook Int 00h to prevent termination in the event of such a bug.
    27                                  ; We first print an error message, then pop the RIP value from 
    28                                  ; the stack, decode the instruction and go to the next 
    29                                  ; instruction after it!
    30                                  start:
    31                                  ;Step 1)
    32                                  ;BREAKPOINT BREAKPOINT BREAKPOINT BREAKPOINT 
    33                                     ;xchg bx, bx
    34                                  ;BREAKPOINT BREAKPOINT BREAKPOINT BREAKPOINT 
    35 00000000 4889E0                      mov rax, rsp
    36 00000003 48C1E805                    shr rax, 5  ;Divide by 16
    37 00000007 48C1E005                    shl rax, 5  
    38 0000000B 4889C4                      mov rsp, rax
    39                                  ;Step 2)
    40 0000000E 48BF-                       mov rdi, _BSS_START_
    40 00000010 [0000000000000000] 
    41 00000018 48B9-                       mov rcx, _BSS_END_
    41 0000001A [0000000000000000] 
    42 00000022 4829F9                      sub rcx, rdi
    43 00000025 31C0                        xor eax, eax
    44 00000027 F3AA                        rep stosb
    45                                  ;Step 3)
    46                                      ;We're gonna be proper and ask DOS to give us the ptr to ENV and CMDLINE
    47                                      ;The cmdline is guaranteed to be at ptr + 37 (+36 gives number of chars)
    48 00000029 B800610000                  mov eax, 0x6100 ;New System Service, get environment ptr
    49 0000002E CD41                        int 0x41
    50 00000030 488915(00000000)            mov qword [_env], rdx
    51 00000037 B801610000                  mov eax, 0x6101 ;New System Service, get cmdline ptr pls in rdx
    52 0000003C CD41                        int 0x41
    53 0000003E B87F000000                  mov eax, 0x7F   ;Max number of chars in buffer (127)
    54 00000043 0FB64A24                    movzx ecx, byte ptr [rdx + 36]  ;Get the number of chars in here
    55 00000047 39C1                        cmp ecx, eax    ;Is the number of chars bigger than 127?
    56 00000049 0F47C8                      cmova ecx, eax  ;If so, replace it with 127
    57 0000004C 488D7A25                    lea rdi, qword ptr [rdx + 37]   ;Get the ptr to the char array
    58 00000050 57                          push rdi    ;Push the pointer to the start of the char array
    59 00000051 31D2                        xor edx, edx    ;Clear the argc counter
    60 00000053 B020                        mov al, " " ;Search for space
    61                                  scanLp:
    62 00000055 F2AE                        repne scasb
    63 00000057 67E310                      jecxz step4 ;No more chars, exit
    64 0000005A F3AE                        repe scasb  ;Skip all the spaces
    65 0000005C 67E30B                      jecxz step4
    66                                      ;rdi points to the char after the first non-space
    67 0000005F 48FFCF                      dec rdi ;Go to the first non-space char
    68 00000062 C647FF00                    mov byte [rdi - 1], 0   ;Replace the last space with a null
    69 00000066 FFC2                        inc edx ;One more char processed
    70 00000068 EBEB                        jmp short scanLp 
    71                                  step4:
    72                                  ;Step 4) 
    73 0000006A C60700                      mov byte [rdi], 0   ;Store a final terminating null
    74 0000006D FFC2                        inc edx ;Add one more (if none, for cmdname)
    75 0000006F 89D1                        mov ecx, edx
    76 00000071 5A                          pop rdx ;Pop the pointer back
    77 00000072 48890D(00000000)            mov qword [_argc], rcx
    78 00000079 488915(00000000)            mov qword [_argv], rdx
    79 00000080 E8(00000000)                call main
    80                                  ;Step 5)
    81 00000085 B9FF000000                  mov ecx, 0xFF
    82 0000008A 39C8                        cmp eax, ecx
    83 0000008C 0F47C1                      cmova eax, ecx 
    84 0000008F 0D004C0000                  or eax, 0x4C00  ;Add the exit code into AH w/o stall
    85 00000094 CD41                        int 0x41 ;Return to DOS
    86                                  
    87                                  ;This symbol is a temporary solution to an awkward GCC behaviour
    88                                  ; where it just decides to call this from within main.
    89                                  __main:
    90 00000096 C3                          ret
