     1                                  %use masm
     2                                  BITS 64
     3                                  ;Need to modify slightly to 
     4                                  extern main
     5                                  extern _BSS_START_
     6                                  extern _BSS_END_
     7                                  extern _argv    ;Argument Vector
     8                                  extern _argc    ;Argument Count
     9                                  extern _env     ;Environment
    10                                  
    11                                  global __start__
    12                                  global __main
    13                                      section .text
    14                                  ;TODO:
    15                                  ;0) Paragraph align the stack
    16                                  ;1) Clean the BSS
    17                                  ;2) Process command line to get argc, argv
    18                                  ;3) Call main.
    19                                  ;4) If eax > 0FFh, set al = 0FFh and 41h/AH=4Ch exit
    20                                  ;Future expansion:
    21                                  ;Hook Int 00h to prevent termination in the event of such a bug.
    22                                  ; We first print an error message, then pop the RIP value from 
    23                                  ; the stack, decode the instruction and go to the next 
    24                                  ; instruction after it!
    25                                  __start__:
    26                                  ;BREAKPOINT BREAKPOINT BREAKPOINT BREAKPOINT
    27                                      ;xchg bx, bx
    28                                  ;BREAKPOINT BREAKPOINT BREAKPOINT BREAKPOINT
    29 00000000 FC                          cld ;Ensure the direction is good (DOS does this anyway)
    30                                  ;Step 0)
    31                                  ;Realign the stack 
    32 00000001 4889E0                      mov rax, rsp
    33 00000004 48C1E804                    shr rax, 4  ;Divide by 16
    34 00000008 48C1E004                    shl rax, 4  
    35 0000000C 4889C4                      mov rsp, rax
    36                                  ;Leave rsp alone now
    37                                  ;Step 1)
    38 0000000F 48BF-                       mov rdi, _BSS_START_
    38 00000011 [0000000000000000] 
    39 00000019 48B9-                       mov rcx, _BSS_END_
    39 0000001B [0000000000000000] 
    40 00000023 4829F9                      sub rcx, rdi
    41 00000026 31C0                        xor eax, eax
    42 00000028 F3AA                        rep stosb
    43                                  ;Step 2)
    44                                      ;We're gonna be proper and ask DOS to give us the ptr to ENV and CMDLINE
    45                                      ;The cmdline is guaranteed to be at ptr + 37 (+36 gives number of chars)
    46 0000002A B800610000                  mov eax, 0x6100 ;New System Service, get environment ptr
    47 0000002F CD41                        int 0x41
    48 00000031 488915(00000000)            mov qword [_env], rdx
    49 00000038 B801610000                  mov eax, 0x6101 ;New System Service, get cmdline ptr pls in rdx
    50 0000003D CD41                        int 0x41
    51 0000003F B87F000000                  mov eax, 0x7F   ;Max number of chars in buffer (127)
    52 00000044 0FB64A24                    movzx ecx, byte ptr [rdx + 36]  ;Get the number of chars in here
    53 00000048 39C1                        cmp ecx, eax    ;Is the number of chars bigger than 127?
    54 0000004A 0F47C8                      cmova ecx, eax  ;If so, replace it with 127
    55 0000004D 488D7A25                    lea rdi, qword ptr [rdx + 37]   ;Get the ptr to the char array
    56 00000051 4889FE                      mov rsi, rdi    ;Save the ptr to the string array in rsi
    57 00000054 31D2                        xor edx, edx    ;Clear the argc counter
    58 00000056 B020                        mov al, " "     ;Search for space
    59                                  makeCstrings:
    60 00000058 F2AE                        repne scasb     ;Search for first space past name
    61 0000005A 67E314                      jecxz endOfCmdLine ;No more chars, exit and terminate current string
    62 0000005D C647FF00                    mov byte [rdi - 1], 0   ;Null terminate this string
    63 00000061 FFC2                        inc edx ;One more string processed
    64 00000063 F3AE                        repe scasb  ;Skip all the spaces
    65 00000065 85C9                        test ecx, ecx
    66 00000067 75EF                        jnz short makeCstrings
    67 00000069 807FFF20                    cmp byte [rdi - 1], " "
    68 0000006D 7502                        jne short endOfCmdLine    ;If the last char was not a space, skip the dec
    69 0000006F FFCA                        dec edx ;Dec the count to balance the below (as we searched thru spaces)
    70                                  endOfCmdLine:
    71 00000071 FFC2                        inc edx ;Add one more char which we are about to terminate
    72 00000073 C60700                      mov byte [rdi], 0   ;Store a final null over terminating 0Dh
    73 00000076 FFC2                        inc edx ;Add one more entry to argv for the command line itself
    74 00000078 488915(00000000)            mov qword [_argc], rdx  ;Save the number of arguments we have
    75 0000007F B800480000                  mov eax, 0x4800
    76 00000084 488D1CD511000000            lea rbx, qword [8*rdx + 0x11] ;Get the number of bytes to allocate
    77 0000008C 48C1EB04                    shr rbx, 4  ;Divide by 16 to get number of paragraphs
    78 00000090 CD41                        int 41h
    79 00000092 0F8289000000                jc exitBad
    80 00000098 4889C5                      mov rbp, rax    ;Store the ptr to the array here
    81                                  ;argv array must have a qword at _argv[_argc] = 0
    82 0000009B 48892D(00000000)            mov qword [_argv], rbp  ;Save the ptr to the char* array
    83                                  ;Place pointer to filename in argv array
    84 000000A2 B802610000                  mov eax, 6102h  ;Get FQN pointer in rdx
    85 000000A7 CD41                        int 41h
    86 000000A9 48895500                    mov qword [rbp], rdx    ;Store the name pointer here
    87 000000AD 483B15(00000000)            cmp rdx, qword [_argc]  ;Are we equal yet?
    88 000000B4 742B                        je short endArgv
    89                                  ;Get pointers to the ASCIIZ command line arguments for argv
    90 000000B6 4889F7                      mov rdi, rsi    ;Get the start of the command line string into rdi
    91 000000B9 BA01000000                  mov rdx, 1      ;Go to the first entry
    92 000000BE 31C9                        xor ecx, ecx
    93 000000C0 FFC9                        dec ecx         ;Get -1 in ecx
    94 000000C2 31C0                        xor eax, eax    ;Scan for nulls
    95 000000C4 B420                        mov ah, " "     ;Prepare for space scanning
    96                                  buildArgv:
    97 000000C6 48897CD500                  mov qword [rbp + 8*rdx], rdi  ;Save rdi as the ptr to the string
    98 000000CB F2AE                        repne scasb   ;Scan for the terminating null
    99 000000CD 86C4                        xchg al, ah 
   100 000000CF F3AE                        repe scasb    ;Scan through the spaces to char 1 of the string
   101 000000D1 48FFCF                      dec rdi     ;Go back to the first char since scasb goes to next char
   102 000000D4 86C4                        xchg al, ah
   103 000000D6 FFC2                        inc edx
   104 000000D8 483B15(00000000)            cmp rdx, qword [_argc]  ;Are we equal yet?
   105 000000DF 75E5                        jne short buildArgv
   106                                  endArgv:
   107 000000E1 31C0                        xor eax, eax
   108 000000E3 488944D500                  mov qword [rbp + 8*rdx], rax    ;Store a ptr to NULL
   109 000000E8 488B0D(00000000)            mov rcx, qword [_argc]  ;Get the regs in for the calling convention
   110 000000EF 488B15(00000000)            mov rdx, qword [_argv]  ;Get the regs in for the calling convention
   111 000000F6 4C8B05(00000000)            mov r8, qword [_env]    ;Get the optional, UNPARSED environment
   112                                      ;We pass a ptr to the environment but it is unparsed as ANSI doesn't 
   113                                      ; request this!
   114                                  ;Step 3) 
   115 000000FD E8(00000000)                call main
   116                                  ;Step 4)
   117 00000102 4C8B05(00000000)            mov r8, qword [_argv]   ;Get the pointer to free this block
   118 00000109 B800490000                  mov eax, 0x4900 ;Explicitly try to free
   119 0000010E CD41                        int 0x41
   120                                  exitCommon:
   121 00000110 B9FF000000                  mov ecx, 0xFF
   122 00000115 39C8                        cmp eax, ecx
   123 00000117 0F47C1                      cmova eax, ecx 
   124 0000011A 0D004C0000                  or eax, 0x4C00  ;Add the exit code into AH w/o stall
   125 0000011F CD41                        int 0x41 ;Return to DOS
   126                                  ;If there is an allocation error, exit
   127                                  exitBad:
   128 00000121 488D150E000000              lea rdx, badMemStr
   129 00000128 B800090000                  mov eax, 0x0900
   130 0000012D CD41                        int 0x41
   131 0000012F B8FF000000                  mov eax, 0xFF
   132 00000134 EBDA                        jmp short exitCommon
   133 00000136 4352543A204E6F7420-     badMemStr db "CRT: Not enough memory",0Ah,0Dh,"$"
   133 0000013F 656E6F756768206D65-
   133 00000148 6D6F72790A0D24     
   134                                  ;GCC provides a call to this main constructor. Since we 
   135                                  ; setup everything in assembly in CRT0, we don't need this.
   136                                  __main:
   137 0000014F C3                          ret
