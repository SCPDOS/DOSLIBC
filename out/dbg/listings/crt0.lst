     1                                  %use masm
     2                                  BITS 64
     3                                  ;ASSEMBLE WITH nasm ./Source/Asm/crt0.asm -o ./out/lib/crt0.lib -f win64 -l ./out/dbg/listings/crt0.lst
     4                                  ;Need to modify slightly to 
     5                                  extern main
     6                                  extern _BSS_START_
     7                                  extern _BSS_SIZE_
     8                                  extern _argv    ;Argument Vector
     9                                  extern _argc    ;Argument Count
    10                                  extern _env     ;Environment
    11                                  
    12                                  global start 
    13                                      section .text
    14                                  ;TODO:
    15                                  ;1) Paragraph align the stack (downwards ofc)
    16                                  ;2) Clean the BSS
    17                                  ;3) Get a pointer to the command line. Count the number of times 
    18                                  ;   a space/tab region appears, to pass as argc in rcx and the 
    19                                  ;   pointer to start of the command line in rdx.
    20                                  ;   Make sure to null terminate each string 
    21                                  ;       (replace first char in space region with 00).
    22                                  ;
    23                                  ;4) Call main.
    24                                  ;5) If eax > 0FFh, set al = 0FFh and 41h/AH=4Ch exit
    25                                  ;Future expansion:
    26                                  ;Hook Int 00h to prevent termination in the event of such a bug.
    27                                  ; We first print an error message, then pop the RIP value from 
    28                                  ; the stack, decode the instruction and go to the next 
    29                                  ; instruction after it!
    30                                  start:
    31                                  ;Step 1)
    32 00000000 4889E0                      mov rax, rsp
    33 00000003 48C1E805                    shr rax, 5  ;Divide by 16
    34 00000007 48C1E005                    shl rax, 5  
    35 0000000B 4889C4                      mov rsp, rax
    36                                  ;Step 2)
    37 0000000E 48BF-                       mov rdi, _BSS_START_
    37 00000010 [0000000000000000] 
    38 00000018 4889F8                      mov rax, rdi
    39 0000001B 48B9-                       mov rcx, _BSS_SIZE_
    39 0000001D [0000000000000000] 
    40 00000025 31C0                        xor eax, eax
    41 00000027 F3AA                        rep stosb
    42                                  ;Step 3)
    43                                      ;We're gonna be proper and ask DOS to give us the ptr to ENV and CMDLINE
    44                                      ;The cmdline is guaranteed to be at ptr + 37 (+36 gives number of chars)
    45 00000029 B800610000                  mov eax, 0x6100 ;New System Service, get environment ptr
    46 0000002E CD41                        int 0x41
    47 00000030 488915(00000000)            mov qword [_env], rdx
    48 00000037 B801610000                  mov eax, 0x6101 ;New System Service, get cmdline ptr pls in rdx
    49 0000003C CD41                        int 0x41
    50 0000003E B87F000000                  mov eax, 0x7F   ;Max number of chars in buffer (127)
    51 00000043 0FB64A24                    movzx ecx, byte ptr [rdx + 36]  ;Get the number of chars in here
    52 00000047 39C1                        cmp ecx, eax    ;Is the number of chars bigger than 127?
    53 00000049 0F47C8                      cmova ecx, eax  ;If so, replace it with 127
    54 0000004C 488D7A25                    lea rdi, qword ptr [rdx + 37]   ;Get the ptr to the char array
    55 00000050 57                          push rdi    ;Push the pointer to the start of the char array
    56 00000051 31D2                        xor edx, edx    ;Clear the argc counter
    57 00000053 B020                        mov al, " " ;Search for space
    58                                  scanLp:
    59 00000055 F2AE                        repne scasb
    60 00000057 807FFF0D                    cmp byte [rdi - 1], 0x0D    ;Are we at terminating char?
    61 0000005B 7413                        je step4
    62 0000005D 67E310                      jecxz step4 ;No more chars, exit
    63 00000060 F3AE                        repe scasb  ;Skip all the spaces
    64 00000062 67E30B                      jecxz step4
    65                                      ;rdi points to the char after the first non-space
    66 00000065 48FFCF                      dec rdi ;Go to the first non-space char
    67 00000068 C647FF00                    mov byte [rdi - 1], 0   ;Replace the last space with a null
    68 0000006C FFC2                        inc edx ;One more char processed
    69 0000006E EBE5                        jmp short scanLp 
    70                                  step4:
    71                                  ;Step 4) 
    72 00000070 C647FF00                    mov byte [rdi - 1], 0   ;Store a final terminating null
    73 00000074 FFC2                        inc edx ;Add one more (if none, for cmdname)
    74 00000076 89D1                        mov ecx, edx
    75 00000078 5A                          pop rdx ;Pop the pointer back
    76 00000079 48890D(00000000)            mov qword [_argc], rcx
    77 00000080 488915(00000000)            mov qword [_argv], rdx
    78 00000087 E8(00000000)                call main
    79                                  ;Step 5)
    80 0000008C B9FF000000                  mov ecx, 0xFF
    81 00000091 39C8                        cmp eax, ecx
    82 00000093 0F47C1                      cmova eax, ecx 
    83 00000096 0D004C0000                  or eax, 0x4C00  ;Add the exit code into AH w/o stall
    84 0000009B CD41                        int 0x41 ;Return to DOS
